<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Swarm Planetary Exploration</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid #333;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        select, input[type="range"], button {
            width: 200px;
            padding: 5px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        
        button {
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #444;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid #333;
            font-size: 12px;
            min-width: 200px;
        }
        
        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        #simulation {
            width: 100%;
            height: 100%;
        }
        
        .planet-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid #333;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <div class="control-group">
                <label>Planet Environment:</label>
                <select id="planetSelect">
                    <option value="earth">Earth</option>
                    <option value="mars">Mars</option>
                    <option value="titan">Titan</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Number of Drones: <span id="droneCount">10</span></label>
                <input type="range" id="droneSlider" min="5" max="50" value="10">
            </div>
            
            <div class="control-group">
                <label>Learning Rate: <span id="learningRate">0.01</span></label>
                <input type="range" id="learningSlider" min="0.001" max="0.1" step="0.001" value="0.01">
            </div>
            
            <div class="control-group">
                <label>Exploration vs Exploitation: <span id="explorationRate">0.3</span></label>
                <input type="range" id="explorationSlider" min="0.1" max="0.9" step="0.1" value="0.3">
            </div>
            
            <div class="control-group">
                <button id="resetBtn">Reset Simulation</button>
                <button id="pauseBtn">Pause/Resume</button>
            </div>
        </div>
        
        <div id="stats">
            <div class="stat-line"><span>Terrain Explored:</span><span id="exploredPercent">0%</span></div>
            <div class="stat-line"><span>Active Drones:</span><span id="activeDrones">0</span></div>
            <div class="stat-line"><span>Collisions:</span><span id="collisions">0</span></div>
            <div class="stat-line"><span>Avg Reward:</span><span id="avgReward">0.0</span></div>
            <div class="stat-line"><span>Generation:</span><span id="generation">1</span></div>
            <div class="stat-line"><span>Best Fitness:</span><span id="bestFitness">0.0</span></div>
        </div>
        
        <div class="planet-info">
            <div id="planetInfo"></div>
        </div>
        
        <canvas id="simulation"></canvas>
    </div>

    <script>
        // Planetary environment configurations
        const PLANETS = {
            earth: {
                name: "Earth",
                gravity: 9.81,
                atmosphericDensity: 1.225,
                windStrength: 0.2,
                color: '#4a90e2',
                terrainColor: '#228b22',
                description: "Standard Earth conditions with moderate gravity and dense atmosphere"
            },
            mars: {
                name: "Mars",
                gravity: 3.71,
                atmosphericDensity: 0.02,
                windStrength: 0.8,
                color: '#cd5c5c',
                terrainColor: '#8b4513',
                description: "Low gravity, thin atmosphere, strong dust storms"
            },
            titan: {
                name: "Titan",
                gravity: 1.35,
                atmosphericDensity: 5.4,
                windStrength: 0.1,
                color: '#ffa500',
                terrainColor: '#696969',
                description: "Low gravity, very dense atmosphere, methane environment"
            }
        };

        // Neural Network for Q-Learning
        class QNetwork {
            constructor(inputSize = 8, hiddenSize = 64, outputSize = 4) {
                this.model = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            inputShape: [inputSize],
                            units: hiddenSize,
                            activation: 'relu',
                            kernelInitializer: 'randomNormal'
                        }),
                        tf.layers.dense({
                            units: hiddenSize,
                            activation: 'relu'
                        }),
                        tf.layers.dense({
                            units: outputSize,
                            activation: 'linear'
                        })
                    ]
                });
                
                this.model.compile({
                    optimizer: tf.train.adam(0.01),
                    loss: 'meanSquaredError'
                });
                
                this.memory = [];
                this.maxMemory = 1000;
            }
            
            predict(state) {
                return tf.tidy(() => {
                    const stateTensor = tf.tensor2d([state]);
                    const prediction = this.model.predict(stateTensor);
                    return prediction.dataSync();
                });
            }
            
            addMemory(state, action, reward, nextState, done) {
                this.memory.push({ state, action, reward, nextState, done });
                if (this.memory.length > this.maxMemory) {
                    this.memory.shift();
                }
            }
            
            async train(batchSize = 32) {
                if (this.memory.length < batchSize) return;
                
                const batch = this.memory.slice(-batchSize);
                const states = batch.map(exp => exp.state);
                const nextStates = batch.map(exp => exp.nextState);
                
                let statesTensor, nextStatesTensor, qValues, nextQValues, targets;
                
                try {
                    statesTensor = tf.tensor2d(states);
                    nextStatesTensor = tf.tensor2d(nextStates);
                    
                    qValues = this.model.predict(statesTensor);
                    nextQValues = this.model.predict(nextStatesTensor);
                    
                    targets = qValues.clone();
                    
                    // Update targets
                    const targetsData = await targets.data();
                    const nextQData = await nextQValues.data();
                    const qShape = qValues.shape;
                    
                    for (let i = 0; i < batch.length; i++) {
                        const exp = batch[i];
                        let target = exp.reward;
                        if (!exp.done) {
                            // Find max Q-value for next state
                            let maxNextQ = -Infinity;
                            for (let j = 0; j < 4; j++) {
                                const qVal = nextQData[i * 4 + j];
                                if (qVal > maxNextQ) maxNextQ = qVal;
                            }
                            target += 0.95 * maxNextQ;
                        }
                        // Update target tensor
                        targetsData[i * 4 + exp.action] = target;
                    }
                    
                    // Create new tensor with updated values
                    targets.dispose();
                    targets = tf.tensor(Array.from(targetsData), qShape);
                    
                    // Train the model
                    const result = await this.model.fit(statesTensor, targets, {
                        epochs: 1,
                        verbose: 0
                    });
                    
                    return result;
                    
                } catch (error) {
                    console.warn('Training error:', error);
                } finally {
                    // Clean up tensors
                    if (statesTensor) statesTensor.dispose();
                    if (nextStatesTensor) nextStatesTensor.dispose();
                    if (qValues) qValues.dispose();
                    if (nextQValues) nextQValues.dispose();
                    if (targets) targets.dispose();
                }
            }
        }

        // Drone class with physics and AI
        class Drone {
            constructor(x, y, id, qNetwork, planet) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = 3;
                this.energy = 100;
                this.maxEnergy = 100;
                this.qNetwork = qNetwork;
                this.planet = planet;
                
                // Physics properties
                this.mass = 0.5;
                this.dragCoeff = 0.1;
                this.thrustPower = 2.0;
                
                // Exploration properties
                this.exploredCells = new Set();
                this.lastState = null;
                this.lastAction = null;
                this.totalReward = 0;
                this.alive = true;
                
                // Trail for visualization
                this.trail = [];
                this.maxTrailLength = 50;
                
                // Colors
                this.color = `hsl(${id * 137.5 % 360}, 70%, 60%)`;
                this.trailColor = `hsl(${id * 137.5 % 360}, 50%, 40%)`;
            }
            
            getState(drones, terrain) {
                // Normalize positions
                const normalizedX = this.x / canvas.width;
                const normalizedY = this.y / canvas.height;
                
                // Find nearest drone
                let nearestDroneDist = Infinity;
                let nearestDroneAngle = 0;
                
                for (let drone of drones) {
                    if (drone.id !== this.id && drone.alive) {
                        const dx = drone.x - this.x;
                        const dy = drone.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDroneDist) {
                            nearestDroneDist = dist;
                            nearestDroneAngle = Math.atan2(dy, dx) / Math.PI;
                        }
                    }
                }
                nearestDroneDist = Math.min(nearestDroneDist / 100, 1); // Normalize
                
                // Check unexplored areas nearby
                let unexploredNearby = 0;
                const checkRadius = 50;
                for (let dx = -checkRadius; dx <= checkRadius; dx += 10) {
                    for (let dy = -checkRadius; dy <= checkRadius; dy += 10) {
                        const checkX = this.x + dx;
                        const checkY = this.y + dy;
                        if (checkX >= 0 && checkX < canvas.width && checkY >= 0 && checkY < canvas.height) {
                            const cellKey = `${Math.floor(checkX/10)}_${Math.floor(checkY/10)}`;
                            if (!terrain.exploredCells.has(cellKey)) {
                                unexploredNearby++;
                            }
                        }
                    }
                }
                unexploredNearby = Math.min(unexploredNearby / 100, 1);
                
                return [
                    normalizedX,
                    normalizedY,
                    this.vx / 10,
                    this.vy / 10,
                    this.energy / this.maxEnergy,
                    nearestDroneDist,
                    nearestDroneAngle,
                    unexploredNearby
                ];
            }
            
            selectAction(state, explorationRate) {
                if (Math.random() < explorationRate) {
                    return Math.floor(Math.random() * 4); // Random action
                }
                
                const qValues = this.qNetwork.predict(state);
                return qValues.indexOf(Math.max(...qValues));
            }
            
            update(drones, terrain, planet) {
                if (!this.alive) return;
                
                // Get current state
                const state = this.getState(drones, terrain);
                
                // Select action
                const action = this.selectAction(state, simulation.explorationRate);
                
                // Apply action (thrust in different directions)
                const thrustMagnitude = this.thrustPower;
                switch (action) {
                    case 0: // Up
                        this.vy -= thrustMagnitude;
                        break;
                    case 1: // Down
                        this.vy += thrustMagnitude;
                        break;
                    case 2: // Left
                        this.vx -= thrustMagnitude;
                        break;
                    case 3: // Right
                        this.vx += thrustMagnitude;
                        break;
                }
                
                // Apply physics
                this.applyPhysics(planet);
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary checking
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.alive = false;
                    simulation.collisions++;
                }
                
                // Energy consumption
                this.energy -= 0.1;
                if (this.energy <= 0) {
                    this.alive = false;
                }
                
                // Calculate reward
                let reward = 0;
                
                // Exploration reward
                const cellKey = `${Math.floor(this.x/10)}_${Math.floor(this.y/10)}`;
                if (!terrain.exploredCells.has(cellKey)) {
                    terrain.exploredCells.add(cellKey);
                    reward += 10;
                }
                
                // Survival reward
                reward += 0.1;
                
                // Collision penalty
                for (let drone of drones) {
                    if (drone.id !== this.id && drone.alive) {
                        const dx = drone.x - this.x;
                        const dy = drone.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < this.size + drone.size + 5) {
                            reward -= 20;
                            simulation.collisions++;
                        }
                    }
                }
                
                // Energy efficiency reward
                reward += (this.energy / this.maxEnergy) * 0.1;
                
                this.totalReward += reward;
                
                // Store experience for learning
                if (this.lastState && this.lastAction !== null) {
                    this.qNetwork.addMemory(
                        this.lastState,
                        this.lastAction,
                        reward,
                        state,
                        !this.alive
                    );
                }
                
                this.lastState = state;
                this.lastAction = action;
                
                // Update trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }
            
            applyPhysics(planet) {
                // Gravity
                this.vy += planet.gravity * 0.01;
                
                // Atmospheric drag
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const dragForce = 0.5 * planet.atmosphericDensity * speed * speed * this.dragCoeff;
                
                if (speed > 0) {
                    const dragX = (this.vx / speed) * dragForce * 0.01;
                    const dragY = (this.vy / speed) * dragForce * 0.01;
                    
                    this.vx -= dragX;
                    this.vy -= dragY;
                }
                
                // Wind effects
                const windX = (Math.sin(Date.now() * 0.001 + this.id) * planet.windStrength * 0.1);
                const windY = (Math.cos(Date.now() * 0.001 + this.id) * planet.windStrength * 0.1);
                
                this.vx += windX;
                this.vy += windY;
                
                // Velocity limits
                const maxVel = 5;
                this.vx = Math.max(-maxVel, Math.min(maxVel, this.vx));
                this.vy = Math.max(-maxVel, Math.min(maxVel, this.vy));
            }
            
            draw(ctx) {
                if (!this.alive) return;
                
                // Draw trail
                ctx.strokeStyle = this.trailColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                for (let i = 1; i < this.trail.length; i++) {
                    ctx.moveTo(this.trail[i-1].x, this.trail[i-1].y);
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Draw drone
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw energy bar
                const barWidth = 20;
                const barHeight = 3;
                const energyPercent = this.energy / this.maxEnergy;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 8, barWidth, barHeight);
                
                ctx.fillStyle = energyPercent > 0.3 ? '#4CAF50' : '#F44336';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 8, barWidth * energyPercent, barHeight);
            }
        }

        // Terrain management
        class Terrain {
            constructor() {
                this.exploredCells = new Set();
                this.totalCells = 0;
                this.calculateTotalCells();
            }
            
            calculateTotalCells() {
                const cellSize = 10;
                this.totalCells = Math.ceil(canvas.width / cellSize) * Math.ceil(canvas.height / cellSize);
            }
            
            getExplorationPercent() {
                return ((this.exploredCells.size / this.totalCells) * 100).toFixed(1);
            }
            
            draw(ctx, planet) {
                // Draw explored areas
                ctx.fillStyle = planet.terrainColor;
                ctx.globalAlpha = 0.1;
                
                for (let cellKey of this.exploredCells) {
                    const [x, y] = cellKey.split('_').map(Number);
                    ctx.fillRect(x * 10, y * 10, 10, 10);
                }
                
                ctx.globalAlpha = 1;
            }
            
            reset() {
                this.exploredCells.clear();
            }
        }

        // Main simulation class
        class Simulation {
            constructor() {
                this.drones = [];
                this.terrain = new Terrain();
                this.qNetwork = new QNetwork();
                this.currentPlanet = 'earth';
                this.running = true;
                this.generation = 1;
                this.collisions = 0;
                this.bestFitness = 0;
                this.learningRate = 0.01;
                this.explorationRate = 0.3;
                
                this.frameCount = 0;
                this.lastTrainingTime = 0;
            }
            
            init(numDrones) {
                this.drones = [];
                this.terrain.reset();
                this.collisions = 0;
                
                // Create drones with shared Q-network
                for (let i = 0; i < numDrones; i++) {
                    const x = Math.random() * (canvas.width - 100) + 50;
                    const y = Math.random() * (canvas.height - 100) + 50;
                    this.drones.push(new Drone(x, y, i, this.qNetwork, PLANETS[this.currentPlanet]));
                }
            }
            
            update() {
                if (!this.running) return;
                
                const planet = PLANETS[this.currentPlanet];
                
                // Update all drones
                for (let drone of this.drones) {
                    drone.update(this.drones, this.terrain, planet);
                }
                
                // Remove dead drones and check for reset condition
                const aliveDrones = this.drones.filter(d => d.alive);
                if (aliveDrones.length === 0 || this.frameCount % 3000 === 0) {
                    this.evolve();
                }
                
                // Train neural network periodically
                if (this.frameCount % 60 === 0 && this.frameCount > 0) {
                    this.qNetwork.train();
                }
                
                this.frameCount++;
            }
            
            evolve() {
                // Calculate fitness for each drone
                let totalFitness = 0;
                let maxFitness = 0;
                
                for (let drone of this.drones) {
                    const fitness = drone.totalReward + (drone.alive ? 50 : 0);
                    totalFitness += fitness;
                    maxFitness = Math.max(maxFitness, fitness);
                }
                
                this.bestFitness = Math.max(this.bestFitness, maxFitness);
                this.generation++;
                
                // Reset simulation with new generation
                const numDrones = this.drones.length;
                this.init(numDrones);
            }
            
            draw(ctx) {
                // Clear canvas with planet-themed background
                const planet = PLANETS[this.currentPlanet];
                const gradient = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, 0,
                    canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
                );
                gradient.addColorStop(0, planet.color + '20');
                gradient.addColorStop(1, planet.color + '05');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw terrain
                this.terrain.draw(ctx, planet);
                
                // Draw drones
                for (let drone of this.drones) {
                    drone.draw(ctx);
                }
                
                // Draw grid for reference
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.2;
                
                for (let x = 0; x < canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            }
            
            changePlanet(planetKey) {
                this.currentPlanet = planetKey;
                // Reset drones with new planetary conditions
                for (let drone of this.drones) {
                    drone.planet = PLANETS[planetKey];
                }
                updatePlanetInfo();
            }
        }

        // Initialize canvas and simulation
        const canvas = document.getElementById('simulation');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const simulation = new Simulation();
        simulation.init(10);
        
        // UI Controls
        const planetSelect = document.getElementById('planetSelect');
        const droneSlider = document.getElementById('droneSlider');
        const droneCount = document.getElementById('droneCount');
        const learningSlider = document.getElementById('learningSlider');
        const learningRate = document.getElementById('learningRate');
        const explorationSlider = document.getElementById('explorationSlider');
        const explorationRate = document.getElementById('explorationRate');
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        
        // Stats elements
        const exploredPercent = document.getElementById('exploredPercent');
        const activeDrones = document.getElementById('activeDrones');
        const collisions = document.getElementById('collisions');
        const avgReward = document.getElementById('avgReward');
        const generation = document.getElementById('generation');
        const bestFitness = document.getElementById('bestFitness');
        
        // Event listeners
        planetSelect.addEventListener('change', (e) => {
            simulation.changePlanet(e.target.value);
        });
        
        droneSlider.addEventListener('input', (e) => {
            droneCount.textContent = e.target.value;
        });
        
        droneSlider.addEventListener('change', (e) => {
            simulation.init(parseInt(e.target.value));
        });
        
        learningSlider.addEventListener('input', (e) => {
            learningRate.textContent = e.target.value;
            simulation.learningRate = parseFloat(e.target.value);
        });
        
        explorationSlider.addEventListener('input', (e) => {
            explorationRate.textContent = e.target.value;
            simulation.explorationRate = parseFloat(e.target.value);
        });
        
        resetBtn.addEventListener('click', () => {
            simulation.init(parseInt(droneSlider.value));
            simulation.generation = 1;
            simulation.bestFitness = 0;
            simulation.collisions = 0;
        });
        
        pauseBtn.addEventListener('click', () => {
            simulation.running = !simulation.running;
            pauseBtn.textContent = simulation.running ? 'Pause' : 'Resume';
        });
        
        function updateStats() {
            exploredPercent.textContent = simulation.terrain.getExplorationPercent() + '%';
            activeDrones.textContent = simulation.drones.filter(d => d.alive).length;
            collisions.textContent = simulation.collisions;
            
            const totalReward = simulation.drones.reduce((sum, drone) => sum + drone.totalReward, 0);
            const avgRewardValue = simulation.drones.length > 0 ? (totalReward / simulation.drones.length).toFixed(1) : '0.0';
            avgReward.textContent = avgRewardValue;
            
            generation.textContent = simulation.generation;
            bestFitness.textContent = simulation.bestFitness.toFixed(1);
        }
        
        function updatePlanetInfo() {
            const planet = PLANETS[simulation.currentPlanet];
            document.getElementById('planetInfo').innerHTML = `
                <strong>${planet.name}</strong><br>
                Gravity: ${planet.gravity}m/s²<br>
                Atmospheric Density: ${planet.atmosphericDensity}kg/m³<br>
                Wind Strength: ${planet.windStrength}<br>
                <em>${planet.description}</em>
            `;
        }
        
        // Animation loop
        function animate() {
            simulation.update();
            simulation.draw(ctx);
            updateStats();
            requestAnimationFrame(animate);
        }
        
        // Initialize
        updatePlanetInfo();
        animate();
        
        // Add mouse interaction for terrain inspection
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // You could add additional mouse interactions here
            // For example, showing detailed info about specific areas
        });
        
        console.log('AI Swarm Planetary Exploration Simulator initialized');
        console.log('Features: Physics simulation, reinforcement learning, cooperative exploration');
    </script>
</body>
</html>